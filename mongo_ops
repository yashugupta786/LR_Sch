import logging
from datetime import datetime
from typing import List, Tuple
from motor.motor_asyncio import AsyncIOMotorClient
from app.models.blob_metadata import FileMeta

logger = logging.getLogger(__name__)


class MongoBlobService:
    """
    Production-grade MongoDB service for blob upload operations and metadata tracking.
    Handles document retrieval, container name lookup, and blob status updates.
    """

    def __init__(self, mongo_uri: str, db_name: str):
        self.client = AsyncIOMotorClient(mongo_uri)
        self.db = self.client[db_name]
        self.run_collection = self.db["run_management"]

    async def get_container_info(self, run_id: str) -> Tuple[str, str]:
        """
        Retrieves tenant_id and engagement_id for the given run_id.

        :param run_id: The unique identifier of the run
        :return: (tenant_id, engagement_id)
        :raises ValueError: If run_id not found or fields are missing
        """
        try:
            doc = await self.run_collection.find_one(
                {"run_id": run_id}, {"tenant_id": 1, "engagement_id": 1}
            )
            if not doc:
                raise ValueError(f"Run not found for run_id: {run_id}")

            tenant_id = doc.get("tenant_id")
            engagement_id = doc.get("engagement_id")

            if not tenant_id or not engagement_id:
                raise ValueError(f"Missing tenant_id or engagement_id for run_id: {run_id}")

            return tenant_id, engagement_id
        except Exception as e:
            logger.exception("Failed to fetch container info from Mongo")
            raise RuntimeError("Failed to retrieve container name info") from e

    async def update_document_blob_info(
        self,
        run_id: str,
        doc_id: str,
        renamed_filename: str,
        blob_path: str,
        sas_url: str,
        step_name: str,
        step_result: str
    ) -> None:
        """
        Updates blob metadata and step log for a document inside run_management.
        """
        timestamp = datetime.utcnow().isoformat()

        try:
            result = await self.run_collection.update_one(
                {
                    "run_id": run_id,
                    "metadata.industries.obligors.documents.doc_id": doc_id
                },
                {
                    "$set": {
                        "metadata.$[].industries.$[].obligors.$[].documents.$[doc].renamed_filename": renamed_filename,
                        "metadata.$[].industries.$[].obligors.$[].documents.$[doc].blob_path": blob_path,
                        "metadata.$[].industries.$[].obligors.$[].documents.$[doc].sas_url": sas_url
                    },
                    "$push": {
                        "metadata.$[].industries.$[].obligors.$[].documents.$[doc].steps": {
                            "step_name": step_name,
                            "result": step_result,
                            "timestamp": timestamp
                        }
                    }
                },
                array_filters=[{"doc.doc_id": doc_id}]
            )

            if result.modified_count == 0:
                logger.warning(f"No document updated for run_id={run_id}, doc_id={doc_id}")
                raise ValueError(f"Document not found or already updated for doc_id={doc_id}")

        except Exception as e:
            logger.exception(f"Mongo update failed for doc_id={doc_id}")
            raise RuntimeError(f"Failed to update blob info for doc_id={doc_id}") from e

    async def get_files_for_blob_upload(
        self,
        run_id: str,
        year: int,
        quarter: str
    ) -> List[FileMeta]:
        """
        Retrieves all documents to upload for a given run_id, year, and quarter.
        Skips files that already have a SAS URL.
        """
        try:
            run_doc = await self.run_collection.find_one({"run_id": run_id})
            if not run_doc:
                raise ValueError(f"No run found with run_id: {run_id}")

            metadata = run_doc.get("metadata")
            if not metadata or not isinstance(metadata, list):
                raise ValueError(f"Metadata section is missing or malformed for run_id: {run_id}")

            file_list = []
            matched_year = False
            matched_quarter = False

            for year_entry in metadata:
                if year_entry.get("year") != year:
                    continue
                matched_year = True

                if year_entry.get("quarter") != quarter:
                    continue
                matched_quarter = True

                for industry_obj in year_entry.get("industries", []):
                    industry = industry_obj.get("industry")
                    for obligor_obj in industry_obj.get("obligors", []):
                        obligor = obligor_obj.get("obligor_name")
                        for doc in obligor_obj.get("documents", []):
                            if doc.get("sas_url"):
                                continue  # Already uploaded

                            file_list.append(FileMeta(
                                run_id=run_id,
                                doc_id=doc.get("doc_id"),
                                original_filename=doc.get("original_filename"),
                                base64_content=doc.get("base64"),
                                year=year,
                                quarter=quarter,
                                industry=industry,
                                obligor=obligor
                            ))

            if not matched_year:
                raise ValueError(f"Year {year} not found for run_id {run_id}")
            if not matched_quarter:
                raise ValueError(f"Quarter {quarter} not found for year {year} and run_id {run_id}")
            if not file_list:
                raise ValueError(f"No files to upload for run_id={run_id}, year={year}, quarter={quarter}")

            return file_list

        except Exception as e:
            logger.exception("Error retrieving documents for blob upload")
            raise RuntimeError("Failed to retrieve files for upload") from e
